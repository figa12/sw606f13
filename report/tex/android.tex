This chapter explains how we used different components from the Android platform. It also explains how drag and drop works, and discusses the problem we had with ListView, including our solution to the problem.
\section{Drag and Drop}
\label{sec:androiddraganddrop}
This section will explain how drag and drop works in Android SDK 11 or greater\citep{androiddraganddropguide}. It will explain how to start a drag, what happens when a view is dragged on the screen, and finally what happens when the view is dropped.

\subsection*{Overview}

Before we begin explaining drag and drop we first need to introduce the terms Listener, View, and ViewGroup.
\begin{description}
\item[View] is a base class for user interface components. A View represents a square on the device's screen, and is responsible for drawing and event handling. An example of the View class could be an ImageView, which is used to display an image.

\item[ViewGroup] is a subclass of the View class, and is a base class for all layouts, which are invisible containers for Views or other ViewGroups.

\item[Listeners] are attached to a View and are mostly used to receive and handle user input. Every Listener has a gesture method, this method is called when the system receive a gesture on the View. A simple example of a Listener is the OnTouchListener, The \lstinline|OnTouch()| method is called every time the OnTouchListener's View receives a touch gesture.
\end{description}

\subsection*{Drag Shadow}
Before we can make a drag we must first create something called a drag shadow. A drag shadow is basically a copy of the View you are trying to drag which follows the position of the finger. \autoref{lst:makedragshadow} shows how to create a drag shadow and start dragging a View.
\begin{lstlisting}[language=java,firstnumber=1,caption={How to create a drag shadow, and start drag},label=lst:makedragshadow]
imageView.setOnTouchListener(new OnTouchListener(){
	public boolean onTouch(View view, MotionEvent motionEvent){
		if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {
			ClipData data = ClipData.newPlainText("", "");
			DragShadowBuilder shadow = new View.DragShadowBuilder(view);
			view.startDrag(data, shadow, null, 0);
			return true;
		}
		else {
			return false;
		}	
	}
});
\end{lstlisting}
\begin{description}
\item[Line 1] set an \lstinline|OnTouchListener| on the \lstinline|imageView|.
\item[Lines 2-3] The \lstinline|OnTouch()| method is called by the system when the \lstinline|imageView| receives an input gesture, and if the gesture is a press motion it will continue.
\item[Lines 4-5] \lstinline|ClipData| is used to move text data. \lstinline|shadow| is initialized with the touched \lstinline|imageView|.

\item[Line 6] The \lstinline|view.startDrag()| starts the drag of the \lstinline|imageView|. This will cause OnDragListeners of every View to be called.

\item[Lines 7-10] The \lstinline|OnTouch()| method returns either true or false based on if the motion event was handled or not.
\end{description}
\subsection*{Drag Events}
An OnDragListener is like the OnTouchListener also attached to a View class. The drag of a View begins when the method \lstinline|view.startDrag()| is called. This will cause the system to draw the drag shadow, and call every OnDragListener with an action. During a drag operation it is possible to enter these four states.
\begin{description}
\item[Started] The OnDragListerner receives a drag event with the action \linebreak \lstinline|ACTION_DRAG_STARTED|. If the OnDragListener returns true it will continue to receive drag events, if it returns false, it will stop receiving drag events, and the View will not be able to accept dragged data.

\item[Dragging] If the user continues to drag the drag shadow and enters a View's boundaries, then the system will send a drag event to the View's OnDragListener with the action \lstinline|ACTION_DRAG_ENTERED|. When the drag shadow exits a View's boundaries the system will send a drag event with the action \linebreak \lstinline|ACTION_DRAG_EXITED|.

\item[Dropped] If the user releases the drag shadow over a View, the View's OnDragListener receives a drag event with the action \lstinline|ACTION_DROP|. However the drag event is not sent if the OnDragListener previously returned false. The OnDragListener is expected to return true if the drop was successfully processed, and otherwise false.

\item[Ended] After the user has released the drag shadow, all the OnDragListeners which still are registered to receive drag events, receives a drag event with the action \lstinline|ACTION_DRAG_ENDED|. This event is done regardless of where the drag shadow has been released.
\end{description}
An implementation and use of drag and drop is shown later in \secref{sec:implementationdraganddrop}.

\section{Listview}\label{sec:listview}
The menu for customization in this project consists of three lists and it would thus be obvious to use the \lstinline|ListView| class from the Android developers guide \citep{androidlayouts}. This proved to be quite the challenge, since the \lstinline|ListView| does not seem to be made for adding and removing items since its initial population. It seems that it is build for showing a dataset in a list form, but if you want to change this dataset during runtime, you run into a lot of problems. There are plenty of examples of people who struggle to use the \lstinline|ListView| class and what seemed to cause a lot of our problems is the \lstinline|NotifyDataSetChanged()| method from the underlying adapter \citep{listviewfail,notifydatasetchanged}. The documentation of this method is very vague and we could not get our list to update with new data.

We chose to implement our own list classes for populating the saved game configurations list and the stations list. By using the \lstinline|LinearLayout| class from the Android developers guide we are able to add and remove views during runtime \citep{androidlayouts}. When we put the \lstinline|LinearLayout| inside a \lstinline|ScrollView| what we get is almost similar to a \lstinline|ListView|.

The first list in the menu contains the children, it is made with the ListView class. This could be done since it does not have to be manipulated after the initial load of children. The second list in the menu contains game configurations called \lstinline|GameLinearLayout|, it is made with \lstinline|LinearLayout| and some of it is described below. The third list in the menu contains station configurations called \lstinline|CustomiseLinearlayout|, it is also made with a \lstinline|LinearLayout| that does almost the same thing as the \lstinline|GameLinearLayout|.

\subsection*{GameLinearLayout}

The class we made to show a list of saved games it is called \lstinline|GameLinearLayout|.

\begin{lstlisting}[language=java,firstnumber=1,caption={The method to create a list item.},label=lst:makeview]
private void makeView(GameConfiguration gameConfiguration) {
    LayoutInflater layoutInflater = (LayoutInflater) getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    // Use same layout style as the profile list
    View gameListItem = layoutInflater.inflate(R.layout.game_list_item);
    
    TextView gameNameTextView = (TextView) gameListItem.findViewById(R.id.gameName);
    gameNameTextView.setText(gameConfiguration.getGameName());

    ImageView gameIconImageView = (ImageView) gameListItem.findViewById(R.id.gameIcon);
    
    Bitmap bitmap = BitmapFactory.decodeFile(PictoFactory.INSTANCE.getPictogram(super.getContext(),gameConfiguration.getStation(0).getCategory()).getImagePath());
    gameIconImageView.setImageBitmap(bitmap);
    
    gameListItem.setOnClickListener(new OnItemClickListener(gameConfiguration));
    gameListItem.setOnLongClickListener(new OnItemLongClickListener(gameConfiguration));

    // Add to the list of visible configurations
    this.visibleGameConfigurations.add(gameConfiguration);
    super.addView(gameListItem);
}
\end{lstlisting}
\begin{description}
\item[Line 1] The method \lstinline|makeView()| takes a \lstinline|GameConfiguration| which contains all relevant information about the saved game.
\item[Lines 2-4] Creates a new \lstinline|View| for the \lstinline|GameConfiguration| based on our layout for a game list item.
\item[Lines 6-7] Gets the name of the game and sets it in the list item.
\item[Lines 9-12] Gets the category pictogram of the first station in the game configuration and sets this as a game icon for the list item.
\item[Lines 14-15] Set a \lstinline|LongClickListener| and a \lstinline|ClickListener| on the item. These are both listeners that we have made. The normal click will select the item and show its details in the customization list. The long click will show a dialog that asks you whether you want to delete it or not.
\item[Lines 18-19] Add the item to the list of saved games, and add the view to the \lstinline|LinearLayout|.
\end{description}
